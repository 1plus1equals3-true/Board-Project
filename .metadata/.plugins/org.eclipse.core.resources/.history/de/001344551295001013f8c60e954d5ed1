<%@ page language="java" contentType="application/json; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ page import="java.sql.*" %>
<%@ page import="lib.DB" %>
<%@ page trimDirectiveWhitespaces="true" %>
<%
response.setContentType("application/json"); // 응답 형식을 JSON으로 설정
response.setHeader("Cache-Control", "no-cache"); // 캐시 방지
out.clear(); // 기존 버퍼 내용을 지워 불필요한 공백을 제거합니다. (필수)

request.setCharacterEncoding("utf-8");

// 응답을 저장할 JSON 문자열을 초기화합니다.
String jsonResponse = "";

String login_id = (String)session.getAttribute("ss_check");
String bidx = request.getParameter("bidx");
String commenttext = request.getParameter("commenttext");

// 필수 입력값 및 로그인 상태 확인
if (login_id == null || bidx == null || commenttext == null || commenttext.trim().isEmpty()) {
    // 필수 정보 누락 시 실패 응답
    jsonResponse = "{\"success\": false, \"message\": \"로그인 또는 필수 입력값이 누락되었습니다.\"}";
} else {
    Connection conn = null;
    PreparedStatement ps = null;
    ResultSet rs = null;

    try {
        conn = DB.getConnection();

        // 1. 댓글 삽입 및 생성된 키(idx) 반환 요청 (Statement.RETURN_GENERATED_KEYS)
        // 이 기능을 지원하지 않는 환경이라면 삽입 직후 SELECT LAST_INSERT_ID() 쿼리를 추가해야 합니다.
        String insertSql = "INSERT INTO comment(bidx, uid, ment, regdate) VALUES(?, ?, ?, NOW())";
        // PreparedStatement 생성 시, 생성된 키를 반환하도록 설정
        ps = conn.prepareStatement(insertSql, Statement.RETURN_GENERATED_KEYS);
        
        ps.setString(1, bidx);
        ps.setString(2, login_id);
        ps.setString(3, commenttext);
        
        int rows = ps.executeUpdate(); // 쿼리 실행

        if (rows > 0) {
            // 2. 새로 삽입된 댓글의 ID(cidx) 가져오기
            String cidx = "";
            rs = ps.getGeneratedKeys();
            if (rs.next()) {
                cidx = rs.getString(1); // 첫 번째 컬럼(idx)의 값을 가져옴
            }
            
            // 3. 댓글 정보 조회 (작성일자, 작성자 이름 포함)
            // m.name이 작성자 이름(comname)이 됩니다.
            String selectSql = "SELECT c.regdate, m.name as comname from comment c "
                             + "LEFT JOIN member m ON c.uid = m.uid "
                             + "WHERE c.idx = ?";
            
            ps.close(); // 이전 PreparedStatement 닫기
            rs.close(); // 이전 ResultSet 닫기
            
            ps = conn.prepareStatement(selectSql);
            ps.setString(1, cidx);
            rs = ps.executeQuery();
            
            String comname = "";
            String comdate = "";
            
            if(rs.next()){
                 comdate = rs.getString("regdate");
                 comname = rs.getString("comname");
            }

            // 4. 성공 JSON 응답 생성
            // 비동기로 댓글을 화면에 추가하는 데 필요한 모든 데이터를 포함합니다.
            // JSON 문자열 생성 시, 따옴표나 줄바꿈 문자에 대한 이스케이프 처리가 필요합니다.
            String safe_commenttext = commenttext.replace("\\", "\\\\").replace("\"", "\\\"").replace("\n", "\\n").replace("\r", "");
            String safe_comname = comname.replace("\\", "\\\\").replace("\"", "\\\"");

            jsonResponse = String.format(
                "{\"success\": true, \"cidx\": \"%s\", \"comname\": \"%s\", \"ment\": \"%s\", \"comdate\": \"%s\", \"cuid\": \"%s\"}",
                cidx, 
                safe_comname,
                safe_commenttext,
                comdate,
                login_id
            );
        } else {
            jsonResponse = "{\"success\": false, \"message\": \"댓글 저장에 실패했습니다.\"}";
        }
        
    } catch (Exception e) {
        // 데이터베이스 오류 시 실패 응답
        // 실제 운영 환경에서는 e.toString() 대신 사용자에게 보여줄 일반적인 오류 메시지를 사용해야 합니다.
        System.err.println("댓글 작성 오류: " + e.getMessage());
        jsonResponse = "{\"success\": false, \"message\": \"데이터베이스 처리 중 오류가 발생했습니다.\"}";
    } finally {
        // 자원 정리
        if (rs != null) try { rs.close(); } catch (SQLException ignore) {}
        if (ps != null) try { ps.close(); } catch (SQLException ignore) {}
        if (conn != null) try { conn.close(); } catch (SQLException ignore) {}
    }
}

// 최종 JSON 응답을 출력하고 버퍼를 비웁니다.
out.print(jsonResponse);
out.flush();
%>